## 进程的地址空间



## ![QQ截图20201109181300](..\images\QQ截图20201109181300.png)







## 新学到的函数setjmp()和longjmp()函数



1. setjmpO的作用是在外层函数中设置可由内层函数返回的返回点。它保存调用函数的栈环
   境于变量env中，该变量之后将被内层函数所调用的longjmp()使用。longjmp()的作用是使用
   外层函数调用setjmp()保存在变量env中的栈环境将控制返回到setjmpO调用之处。
2. 由于setjmp(身兼二职:其一是保存当前的栈环境，然后返回;其二是作为longjmp( 的
   专移目的地，因此它有两种返回值。-一种是调用setimp(时的返回值，其值为0;另一种是从内
   层函数调用longjmp(时的返回值，其值为非零。故setjmp(总是放在if语句的条件表达式内。



longjmp必须在setjmp调用之后，而且longjmp必须在setjmp的作用域之内。具体来说，在一个函数中使用setjmp来初始化一个全局标号，然后只要该函数未曾返回，那么在其它任何地方都可以通过longjmp调用来跳转到
setjmp的下一条语句执行。实际上setjmp函数将发生调用处的局部环境保存在了一个jmp_buf的结构当中，只要主调函数中对应的内存未曾释放
（函数返回时局部内存就失效了），那么在调用longjmp的时候就可以根据已保存的jmp_buf参数恢复到setjmp的地方执行。



非局部转移有时很有用。例如，编译程序通常用一个主控程序逐行读入源文件并对它进行
词法分析、语法分析等处理。当发现存在语法错误时，一-般不会终止程序，而是要设法回到主
控程序继续后继处理。但是，此时往往已经嵌套了好多层函数调用。如果仍按照调用顺序逐层
返回，则在每一个函数调用返回之后都必须进行错误检查。这种做法显然既烦琐又低效。使用
setjmp(和longimp()可以很方便地解决这种问题。





## 孤儿由1号进程收养



父进程先于子进程结束，则子进程变为孤儿进程，由1号进程收养。

![QQ截图20201109145911](..\images\QQ截图20201109145911.png)





## waitpid()函数

功能：

waitpid会暂时停止目前进程的执行，直到有信号来到或子进程结束。



 **pid** 

 从参数的名字pid和类型pid_t中就可以看出，这里需要的是一个进程ID。但当pid取不同的值时，在这里有不同的意义。

1.  pid>0时，只**等待进程ID等于pid的子进程**，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束，waitpid就会一直等下去。
2.  **pid=-1时，等待任何一个子进程退出，没有任何限制，此时waitpid和wait的作用一模一样。**
3.  **pid=0时，等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会对它做任何理睬。**
4.  **pid<-1时，等待一个指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值。**

 
 

 **options**

 options提供了一些额外的选项来控制waitpid，目前在Linux中只支持WNOHANG和WUNTRACED两个选项，这是两个常数，可以用"|"运算符把它们连接起来使用，比如：

 `**ret=waitpid(-1,NULL,WNOHANG | WUNTRACED);**` 

如果我们不想使用它们，也可以把options设为0，如：



 `**ret=waitpid(-1,NULL,0);**`







![QQ截图20201109180639](..\images\QQ截图20201109180639.png)



## fork函数



**fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：**
     1）在父进程中，fork返回新创建子进程的进程ID；
     2）在子进程中，fork返回0；
     3）如果出现错误，fork返回一个负值；